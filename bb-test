#!/usr/bin/env bb

(ns bb-test
	(:require [clojure.tools.cli :refer [parse-opts]]	
	          [babashka.tasks :refer [run shell]]
		  [babashka.curl :as curl]
		  [cheshire.core :as json]
		  [environ.core :refer [env]]
		  [clojure.java.io :as io]))


; lein
(defn lein-new [repo]
	(shell (str "lein new " repo)))

(defn lein-new-quiet 
	[repo]
		(shell (str "lein new " repo " >dev/null 2>&1")))

(defn lein-repo-exists? [repo]
	(.exists (io/file repo)))

(defn lein-delete [repo]
	(shell (str "rm -r " repo)))

; github
(def user-url "https://api.github.com/user/repos")
(def token (env :token))
(def username (env :profile))
(def headers {"Accept" "application/json"
	      "Authorization" (str "Bearer " token)})


(defn get-repos-request 
	[]
	(curl/get user-url {:headers headers}))

(defn make-repo-request 
	[repo-name]
	(curl/post user-url {
			:headers headers
			:body    (json/generate-string {"name" repo-name})
			:throw false}))

(defn get-repos
	[]
	(let [resp (get-repos-request)]
		(map #(get % "name") (json/parse-string (:body resp)))))

(defn git-repo-exists?
	[repo-name]
	(let [repos (get-repos)]
		(if (empty? (filter #(= repo-name %) repos))
			false
			true)))

(defn make-repo
	[repo-name]
	(let [repos (get-repos)]
		(if (empty? (filter #(= repo-name %) repos))
			(make-repo-request repo-name)
			(println "error"))))

(defn make-repo-url
	[owner repo]
	(str "https://api.github.com/repos/" owner "/" repo))

(defn delete-repo-request
	[repo-name]
	(curl/delete (make-repo-url username repo-name) {
		:headers headers
		:throw false
	}))

(defn git-delete-repo
	[repo-name]
	(let [repos (get-repos)]
		(if (empty? (filter #(= repo-name %) repos))
		(println "error")
		(delete-repo-request repo-name))))

(defn get-clone-repo-url
	[repo-name]
	(get (json/parse-string (:body (curl/get (make-repo-url username repo-name)) {
		:headers headers
		:throw false
	})) "clone_url"))

(defn clone-repo
	[repo-name]
	(let [url (get-clone-repo-url repo-name)]
		(shell (str "git clone" url))))

; leingit

(defn leingit-make-repo
	[repo-name]
		(let [lein-exists (lein-repo-exists? repo-name)
			  git-exists  (git-repo-exists? repo-name)]
			  (cond
			  	(and lein-exists git-exists) (println "Repo exists both locally and in github.")
				(= lein-exists true)         (do
												(println "Repo exists locally. Pushing to git."))
				(= git-exists true)		     (do
												(println "Repo exists in git. Cloning locally.")
												(println (get-clone-repo-url repo-name)))
				:else                        (do
												(println "Creating repo")
												(lein-new repo-name)
												(shell (str "cd " repo-name)
												(make-repo repo-name)
												(shell "git init")
												(shell "git add .")
												(shell "git commit -m \"first commit\"")
												(shell "git branch -M main")
												(shell (str "git remote add origin " (get-clone-repo-url repo-name)))
												(shell "git push -u origin main")
												(println "Created new repo."))))))

(git-delete-repo "hello")
(leingit-make-repo "hello")
(leingit-make-repo "hello")

; opts
(def cli-options
	[["-n" "--name NAME" "Project name"]])

(def parsed-args (parse-opts *command-line-args* cli-options))

(let [options (:options parsed-args)]
    (if (contains? options :name)
        (println "Pass") (println "Fail")))

